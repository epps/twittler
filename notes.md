# Twittler: MS Pre-course Project

## Basic Requirements:
- [ ] 1 .Display tweets (you can decide on how to do this, eg w/ a button, etc.)
- [ ] 2. Display timestamps
- [ ] 3. Design UI so that it's aesthetically attractive and something you'd use 
- [ ] 4. Allow users to click on a username to see that user's timeline

### Notes from 05/29/2015 - Day One
After looking through data_generator.js to get a fix on the data structures and how tweets are added to the stream, I turned my attention to the JS block in index.html. Almost immediately, I realized that I didn't really understand how the while loop worked. 

First, the variable `index`, which holds `streams.home.length - 1`:

`streams.home.length` is an always growing value thanks to `scheduleNextTweet` which randomly calls `generateRandomTweet()`. Initially, there will be at least 10 tweets generated by a for loop. Then new tweets will be generated at random intervals. 

What I can figure out is:
+ Why aren't there ever more than 11 tweets in the initial batch?
+ Why doesn't this list continue to grow? If `index`'s value is always growing and the while loop runs so long as `index >= 0`, why doesn't this continually add tweets to the body?

#### NOTE
I deleted `- 1` from `streams.home.length - 1` expecting to see the number of tweets in the list change; instead I broke the code and received this error message: `Uncaught TypeError: Cannot read property 'user' of undefined`. 

---
#### ANSWERS:
It dawned on me (embarrassingly) that I was overly fixated on the while loop and hadn't stopped to consider that the variable assigment locks the initial value of `index` in place at 10, which happens to be the number of tweets generated by the for loop in data_generator.js. A simple `console.log(index)` before and after the while loop confirmed this. The line of code that changes `index`'s value is the decrementer at the end of the while loop, which breaks once `index` reaches -1.

This also explains why removing `- 1` broke the code and resulted in a TypeError: at the time the document ready event fires, there are only 10 tweets, even though the 11th one follows nearly immediately after this. 

---

## 2. Display timestamps
An aesthetically unpleasing and rough solution to this requirement is simple adding to the string concatenation found in the starting source code:
- Before: `$tweet.text('@' + tweet.user + ': ' + tweet.message);`
- After: `$tweet.text('@' + tweet.user + ': ' + tweet.message + ' ' + tweet.created_at);`

Formatting the date will require either a library (check out [Moment.js](http://momentjs.com/) or [this list of date libraries](http://codegeekz.com/6-javascript-date-libraries-for-developers/)) or some custom JS code (check out [this sitepoint article on dates](http://www.sitepoint.com/beginners-guide-to-javascript-date-and-time/))

## 1. Display tweets
My first thought for how to display tweets was a button that would the next tweet in the `streams.home` array. 

To do this, I'll need to:
1. Create a button and add an event listener
2. Write an event handler function that will fetch the next five tweets from `streams.home`

Where I'm at now: I've created a button and built an even handler that fetches the next tweet from the `streams.home` array, but instead of adding  it to the list, lengthing the list of tweets by one element, it __replaces__ the first element in the list. I expected the function to add `<div>` after `<div>` to the list, and since I can't identify a part of the code that's capping the displayed tweets at 11, I'm stuck for the moment. One solution is to avoid the issue altogether by writing some HTML, into which I could inject the tweets (e.g. a container element that I could style down the line).

### Notes from 05/30/2015 - Day Two
I've tried several changes (e.g. creating a container for the tweets) but I'm still running into the same behavior: the on click function replaces the first element in the list of tweets instead of adding to the list. I've also noticed that the last item in the list (chronologically speaking, the first tweet generated by the `generateRandomTweet()`) gets pushed out of the list. Here's a [screenshot of the behavior](http://cl.ly/image/1x0T1b313G17).

Here's the button code:
    ```javascript
    $('button').on('click', function() {
      nextTweet = streams.home[tweetCounter];
      $tweet.text('@' + nextTweet.user + ': ' + nextTweet.message);
      $('.tweet').first().before($tweet);
      tweetCounter++;
    });
    ```

I've gone ahead and worked around this problem; however, I'm bookmarking it for later since I think solving it will either point out some painfully obvious thing I've been overlooking or teach me something new about jQuery. 

## 4. Allow users to click on a username to see that user's timeline
My first thought for how to create this behavior was to add users' respective handles to each tweet as a data attribute that I could pull from later to filter and/or fetch tweets (based on the instructions, it sounds like the I'm supposed to fetch tweets from `streams.users[user_name]`).

To do this, I'll need to:
1. Wrap users' names in an anchor tag
2. Add users' names to data attribute
3. Create an event listener for the links
4. Create an event handler that:
    * Grabs the users name from an attribute
    * Filters existing tweets or fetches (a certain number of) tweets from `streams.users.[user_name]`
    * Populates container `div` with the retrieved tweets
    * Hides `streams.home` and displays the newly created `div` 
    * (Optionally) displays user-specific elements, such as user bio, about, etc.
5. Either refactor or re-create the "Show next tweet" button so that it only shows tweets from the selected user's stream

### Notes from 05/31/2015 - Day Three
I struggled to decide on a way of handling the task of displaying user-specific tweets. Initially, I thought of extending while loop that came with the original source code to build hidden containers of user-specific tweets wrapped in HTML. I created a switch block to handle this, but as I began to test it, I realized it was bringing too much code to a problem that could be solved another way. 

I finally decided on upping the number of initially generated tweets, then filtering this list with an event handler. Simpler solution, but much harder to write functioning code for. One attempt only worked for content generated immediately upon the document ready event; another solution over-reached and removed / hid parents of parent elements. 

I finally arrived at something that worked as I wanted for both initial and dynamically generated content: 
  ```javascript
    $('.container').on('click', 'a', function(e) { // in order to have this click event work for dynamically generated content, you need to target the parent container
    e.preventDefault();
    var user = $(this).attr('class');
    // $('a').not('.' + user).parent().remove(); Works for only non-dynamically generated elements
    $('.container').find('a').not('.' + user).parent().remove(); // had to begin my selection that the container level so that the behavior would apply to dynamically generated content, too

  });
  ```

Now I need to change the behavior of the button so that it only shows tweets for the selected user, as well as add a way of returning to the home stream. 

### Notes from 06/01/2015 - Day Four
First thing I see in the code I wrote yesterday is the potential problem lurking behind the decision to remove tweets from the home stream instead of simply hiding them. 

Swapping out `.hide()` for `.fadeToggle()` immediately addressess and resolves this concern. 

Changing the behavior of the button from showing the next tweet from `streams.home` to showing the next tweet from `streams.users.<specific-user>` has pointed me towards some interesting questions. 

When I click on a user's name the second time, the home stream fades back in, but the button will now show new tweets from only the previously selectected user. 

I'll need to look into some way of communicating the change between the home stream and the user-specific stream to toggle between two event handler on the button. 

